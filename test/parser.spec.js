const assert = require('assert');
const os = require('os');
const generateDocumentation = require("../dist/generateDocumentation");
const convertToPlant = require("../dist/convertToPlant");

describe("Parse Typescript Playground codes", () => {

	it('generate PlantUML for Abstract/AbstractClass.ts', () => {
		assert.equal(convertToPlant.convertToPlant(generateDocumentation.generateDocumentation(["sample/Abstract/AbstractClass.ts"])),
			['@startuml',
				'abstract class AbstractClass {',
				'    +{abstract} ToTest(): any',
				'}',
				'@enduml'].join(os.EOL));
	});

	it('generate PlantUML for Classes/Greeter.ts', () => {
		assert.equal(convertToPlant.convertToPlant(generateDocumentation.generateDocumentation(["sample/Classes/Greeter.ts"])),
			['@startuml',
				'class Greeter {',
				'    +greeting: string',
				'    +prefix: string',
				'    +greet(prefix?: string): string',
				'    +greet(): string',
				'}',
				'@enduml'].join(os.EOL));
	});
	
	it('generate PlantUML for Enum/Enum.ts', () => {
		assert.equal(convertToPlant.convertToPlant(generateDocumentation.generateDocumentation(["sample/Enum/Enum.ts"])),
			['@startuml',
				'enum Semaphore {',
				'    RED',
				'    GREEN',
				'    YELLOW',
				'}',
				'@enduml'].join(os.EOL));
	});

	it('generate PlantUML for Inheritance', () => {
		assert.equal(convertToPlant.convertToPlant(generateDocumentation.generateDocumentation(["sample/Inheritance/index.ts"])),
			['@startuml',
				'class Animal {',
				'    +name: string',
				'    +move(distanceInMeters?: number): void',
				'}',
				'class Horse extends Animal {',
				'    +move(distanceInMeters?: number): void',
				'}',
				'class Snake extends Animal {',
				'    +move(distanceInMeters?: number): void',
				'}',
				'@enduml'].join(os.EOL));
	});

	it('generate PlantUML for Generics/Complex.ts', () => {
		assert.equal(convertToPlant.convertToPlant(generateDocumentation.generateDocumentation(["sample/Generics/Complex.ts"])),
			['@startuml',
				'interface GenericInterface<T extends string> {',
				'    +method(arg: T): T',
				'}',
				'interface GenericInterface2<T extends string> {',
				'    +property?: T',
				'}',
				'interface GenericInterface3<T extends string, A extends number> extends GenericInterface2 {',
				'    +method2(arg: A): A',
				'}',
				'class GenericClass<T extends string, A extends number> implements GenericInterface, GenericInterface3 {',
				'    +property?: T',
				'    +method(arg: T): T',
				'    +method2(arg: A): A',
				'}',
				'class GenericClass2<T extends string> implements GenericInterface2 {',
				'    +property?: T',
				'}',
				'class ConcreteClass extends GenericClass implements GenericInterface, GenericInterface2 {',
				'    +property: string',
				'}',
				'@enduml'].join(os.EOL));
	});

	it('generate PlantUML for Generics/Greeter.ts', () => {
		assert.equal(convertToPlant.convertToPlant(generateDocumentation.generateDocumentation(["sample/Generics/Greeter.ts"])),
			['@startuml',
				'class Greeter<T> {',
				'    +greeting: T',
				'    +greet(): T',
				'}',
				'@enduml'].join(os.EOL));
	});

	it('generate PlantUML for Inheritance/autos.ts', () => {
		assert.equal(convertToPlant.convertToPlant(generateDocumentation.generateDocumentation(["sample/Inheritance/autos.ts"])),
			['@startuml',
				'class Vehicle implements IVehicle {',
				'    +color: string',
				'    +start(type: string): string',
				'}',
				'interface IVehicle {',
				'    +start(type: string): string',
				'}',
				'class Car extends Vehicle {',
				'    +start(): string',
				'}',
				'interface ITrunk {',
				'    +openTrunk(): void',
				'}',
				'interface IWindow {',
				'    +openWindow(): void',
				'}',
				'class Sedan extends Car implements ITrunk, IWindow {',
				'    +start(): string',
				'    +openTrunk(): void',
				'    +openWindow(): void',
				'}',
				'class Truck extends Vehicle {',
				'    +start(): string',
				'}',
				'@enduml'].join(os.EOL));
	});

	it("generate PlantUML for RayTracer", () => {
		assert.equal(convertToPlant.convertToPlant(generateDocumentation.generateDocumentation(["sample/RayTracer/index.ts"])),
			['@startuml',
				'class Vector {',
				'    +x: number',
				'    +y: number',
				'    +z: number',
				'    +{static} times(k: number, v: Vector): Vector',
				'    +{static} minus(v1: Vector, v2: Vector): Vector',
				'    +{static} plus(v1: Vector, v2: Vector): Vector',
				'    +{static} dot(v1: Vector, v2: Vector): number',
				'    +{static} mag(v: Vector): number',
				'    +{static} norm(v: Vector): Vector',
				'    +{static} cross(v1: Vector, v2: Vector): Vector',
				'}',
				'interface Ray {',
				'    +start: Vector',
				'    +dir: Vector',
				'}',
				'interface Intersection {',
				'    +thing: Thing',
				'    +ray: Ray',
				'    +dist: number',
				'}',
				'class Color {',
				'    +r: number',
				'    +g: number',
				'    +b: number',
				'    +{static} scale(k: number, v: Color): Color',
				'    +{static} plus(v1: Color, v2: Color): Color',
				'    +{static} times(v1: Color, v2: Color): Color',
				'    +{static} white: Color',
				'    +{static} grey: Color',
				'    +{static} black: Color',
				'    +{static} background: Color',
				'    +{static} defaultColor: Color',
				'    +{static} toDrawingColor(c: Color): { r: number; g: number; b: number; }',
				'}',
				'interface Surface {',
				'    +diffuse: (pos: Vector) => Color',
				'    +specular: (pos: Vector) => Color',
				'    +reflect: (pos: Vector) => number',
				'    +roughness: number',
				'}',
				'interface Thing {',
				'    +intersect: (ray: Ray) => Intersection',
				'    +normal: (pos: Vector) => Vector',
				'    +surface: Surface',
				'    +destroy(): void',
				'    +destroy(name: string): void',
				'}',
				'interface Light {',
				'    +pos: Vector',
				'    +color: Color',
				'}',
				'class Camera {',
				'    +forward: Vector',
				'    +right: Vector',
				'    +up: Vector',
				'    +pos: Vector',
				'}',
				'interface Scene {',
				'    +things: Thing[]',
				'    +lights: Light[]',
				'    +camera: Camera',
				'}',
				'class Plane implements Thing {',
				'    +normal: (pos: Vector) => Vector',
				'    +intersect: (ray: Ray) => Intersection',
				'    +surface: Surface',
				'}',
				'class Sphere implements Thing {',
				'    +radius2: number',
				'    +center: Vector',
				'    +surface: Surface',
				'    +normal(pos: Vector): Vector',
				'    +intersect(ray: Ray): { thing: this; ray: Ray; dist: number; }',
				'}',
				'class RayTracer {',
				'    -maxDepth: number',
				'    -intersections(ray: Ray, scene: Scene): Intersection',
				'    -testRay(ray: Ray, scene: Scene): number',
				'    -traceRay(ray: Ray, scene: Scene, depth: number): Color',
				'    -shade(isect: Intersection, scene: Scene, depth: number): Color',
				'    -getReflectionColor(thing: Thing, pos: Vector, normal: Vector, rd: Vector, scene: Scene, depth: number): Color',
				'    -getNaturalColor(thing: Thing, pos: Vector, norm: Vector, rd: Vector, scene: Scene): any',
				'    +render(scene: any, ctx: any, screenWidth: any, screenHeight: any): void',
				'}',
				'@enduml'].join(os.EOL));
	});

	it('generate PlantUML for src/index.ts', () => {
		assert.equal(convertToPlant.convertToPlant(generateDocumentation.generateDocumentation(["src/index.ts"])),
			['@startuml',
				'interface ISerializeSymbol {',
				'    +name: string',
				'    +type: string',
				'    +questionToken?: boolean',
				'}',
				'interface ISerializeSignature {',
				'    +parameters: ISerializeSymbol[]',
				'    +returnType: string',
				'}',
				'interface ISerializeMember extends ISerializeSymbol {',
				'    +modifierType: string',
				'    +keyword?: string',
				'    +constraint?: string',
				'}',
				'interface ISerializeInterface extends ISerializeSymbol {',
				'    +structure: STRUCTURE',
				'    +members: ISerializeMember[]',
				'    +extends?: string',
				'    +implements?: string[]',
				'    +parameters?: ISerializeMember[]',
				'}',
				'interface ISerializeEnum extends ISerializeInterface {',
				'    +structure: STRUCTURE.ENUM',
				'}',
				'interface ISerializeClass extends ISerializeInterface {',
				'    +structure: STRUCTURE.CLASS',
				'    +constructors: ISerializeSignature[]',
				'    +keyword?: string',
				'}',
				'enum MODIFIER_TYPE {',
				'    PUBLIC',
				'    PRIVATE',
				'    PROTECTED',
				'}',
				'enum MEMBER_TYPE {',
				'    PROPERTY',
				'    METHOD',
				'    CONSTRUCTOR',
				'    INDEX',
				'    ENUM',
				'    PARAMETER',
				'}',
				'enum CLASS_MEMBER_KEYWORD {',
				'    ABSTRACT',
				'    STATIC',
				'}',
				'enum STRUCTURE {',
				'    CLASS',
				'    INTERFACE',
				'    ENUM',
				'}',
				'@enduml'].join(os.EOL));
	});

});
